# 🌳 树的算法与题目总结
>此文档记录了与树相关的算法和题目内容，题目来源于洛谷。

## 📌 1. 已知前序后序遍历，求解中序遍历个数

💡 题目来源[洛谷 P1229 - 已知前序后序遍历，求中序遍历个数](https://www.luogu.com.cn/problem/P1229)

## 题目描述

我们都很熟悉二叉树的前序、中序、后序遍历，在数据结构中常提出这样的问题：已知一棵二叉树的前序和中序遍历，求它的后序遍历，相应的，已知一棵二叉树的后序遍历和中序遍历序列你也能求出它的前序遍历。然而给定一棵二叉树的前序和后序遍历，你却不能确定其中序遍历序列，考虑如下图中的几棵二叉树：

![](https://cdn.luogu.com.cn/upload/image_hosting/w75s9yip.png)

所有这些二叉树都有着相同的前序遍历和后序遍历，但中序遍历却不相同。

## 输入格式

共两行，第一行表示该二叉树的前序遍历结果 $s_1$，第二行表示该二叉树的后序遍历结果 $s_2$。


保证至少存在一棵二叉树满足给出的信息，s<sub>1</sub>, s<sub>2</sub>  中只含小写字母，且在某个字符串中不存在相同的字母。

## 输出格式

输出可能的中序遍历序列的总数，结果不超过 $2^{63}-1$。

## 样例 #1

### 样例输入 #1

```
abc                           
cba
```

### 样例输出 #1

```
4
```

## 💡 解题思路
>首先我们需要知道，只有在树中都是一个儿子的时候，才会产生不同的中序遍历结果。例如前序出现AB，后序要出现BA，刚好反过来。于是，我们可以依据这个思想来写代码。

```cpp
#include <iostream>
#include <vector>
using namespace std;
int main(void)
{
  string fir, thi;
  cin >> fir >> thi;
  int result = 0;
  for (int i = 0; i < fir.length(); i++)
  {
    for (int j = 1; j < thi.length(); j++)
    {
      if (fir[i] == thi[j] && fir[i + 1] == thi[j - 1]) //验证是不是前序AB，后序BA的情况
        result++;
    }
  }
  cout << (1 << result); // 按位运算，真是太妙了，左移一位
  return 0;
}
```
## 📌 2.堆
![堆的引入](./照片/堆1.png)

### 2.1 二叉堆基础知识点讲解:
![二叉堆照片1](./照片/堆2.png)

### 2.2 二叉堆的操作:
堆的操作有两种:上浮和下沉。

![二叉堆照片2](./照片/堆3.png)

![二叉堆照片3](./照片/堆4.png)

![二叉堆照片4](./照片/堆5.png)

### 2.3 二叉堆的代码:

💡 题目来源[洛谷p3378 堆](https://www.luogu.com.cn/problem/P3378)
# 【模板】堆

## 题目描述

给定一个数列，初始为空，请支持下面三种操作：

1. 给定一个整数 $x$，请将 $x$ 加入到数列中。
2. 输出数列中最小的数。
3. 删除数列中最小的数（如果有多个数最小，只删除 $1$ 个）。

## 输入格式

第一行是一个整数，表示操作的次数 $n$。  
接下来 $n$ 行，每行表示一次操作。每行首先有一个整数 $op$ 表示操作类型。
- 若 $op = 1$，则后面有一个整数 $x$，表示要将 $x$ 加入数列。
- 若 $op = 2$，则表示要求输出数列中的最小数。
- 若 $op = 3$，则表示删除数列中的最小数。如果有多个数最小，只删除 $1$ 个。

## 输出格式

对于每个操作 $2$，输出一行一个整数表示答案。

## 样例 #1

### 样例输入 #1

```
5
1 2
1 5
2
3
2
```

### 样例输出 #1

```
2
5
```

## 💡 解题思路
>上浮用push()函数实现，完成插入新元素的功能，对应优先队列的入队；下沉用pop()函数实现，完成删除堆头的功能，对应优先队列的删除队头。
```cpp
#include <iostream>
#include <vector>
using namespace std;
void push(int x, vector<int> &heap, int &len)
{
  heap[++len] = x; // 将新元素 x 插入到堆的末尾
  int i = len;     // 从新插入的节点开始
  while (i > 1 && heap[i] < heap[i / 2])
  { // 如果当前节点比父节点小，交换它们
    swap(heap[i], heap[i / 2]);
    i /= 2; // 向上移动到父节点
  }
}
void pop(vector<int> &heap, int &len)
{
  heap[1] = heap[len--]; // 用最后一个元素替换堆顶，但可能不满足最小堆的特性，故而需要进行调整
  int i = 1;
  while (2 * i <= len)
  {                  // 循环条件：当前节点有子节点
    int son = 2 * i; // 假设左子节点更小
    if (son + 1 <= len && heap[son + 1] < heap[son])
    {
      son++; // 如果右子节点更小，选择右子节点，相当于是和上面的配套使用，一开始假设的是左儿子更小，比较后再进行调整选择哪一个
    }
    if (heap[son] < heap[i])
    {
      swap(heap[son], heap[i]);
      i = son; // 继续向下调整
    }
    else
    {
      break; // 堆已满足性质，退出循环
    }
  }
}

int main(void)
{
  int n;
  cin >> n;                // 输入操作次数
  vector<int> heap(n + 1); // 创建堆，长度为 n+1（从下标 1 开始存储元素）
  int len = 0;             // 堆的当前大小

  while (n--)
  {         // 循环处理每个操作
    int op; // 操作类型：1 插入，2 取出堆顶，3 删除堆顶
    cin >> op;
    if (op == 1)
    { // 插入操作
      int x;
      cin >> x;
      push(x, heap, len); // 插入元素 x
    }
    else if (op == 2)
    { // 输出堆顶元素
      cout << heap[1] << endl;
    }
    else
    { // 删除堆顶操作
      pop(heap, len);
    }
  }
  return 0;
}
```

💡 题目来源[洛谷p1090 堆](https://www.luogu.com.cn/problem/P1090)

```cpp
#include <iostream>
#include <vector>
using namespace std;
void push(int x, vector<int> &arr, int &len)
{
  arr[++len] = x; // 先将元素插入
  int i = len;
  while (i > 1 && arr[i] < arr[i / 2])
  {
    swap(arr[i], arr[i / 2]);
    i = i / 2;
  }
}
void pop(vector<int> &arr, int &len)
{
  arr[1] = arr[len--];
  int i = 1;
  while (2 * i <= len)
  {
    int son = 2 * i;
    // 下面开始判断最小的是左儿子还是右儿子
    if (son + 1 <= len && arr[son + 1] < arr[son])
    {
      son++;
    }
    if (arr[son] < arr[i])
    {
      swap(arr[son], arr[i]);
      i = son;
    }
    else
    {
      break;
    }
  }
}
int main(void)
{
  int n;
  cin >> n;
  int len = 0;
  vector<int> arr(n + 1); // 从1开始计数吧，0索引的直接不用
  for (int i = 1; i <= n; i++)
  {
    cin >> arr[i];
    push(arr[i], arr, len);
  }
  int sum = 0, temp_sum = 0;
  while (len != 1)
  {
    int a = arr[1];
    pop(arr, len);
    int b = arr[1];
    pop(arr, len);
    temp_sum = a + b;
    sum += temp_sum;
    push(temp_sum, arr, len);
  }
  cout << sum;
  return 0;
}
```